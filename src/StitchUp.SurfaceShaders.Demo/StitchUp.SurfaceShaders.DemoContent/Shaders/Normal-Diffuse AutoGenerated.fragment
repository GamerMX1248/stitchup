fragment Diffuse_AutoGenerated;

// Need to #include Lambert.fragment in .stitchedeffect

[params]
float4 Color : DIFFUSE_COLOR = float4(1, 1, 1, 1);
float3 camera_position : CAMERA_POSITION;
float4 ambient_light_diffuse_color : AMBIENT_LIGHT_DIFFUSE_COLOR;

[textures]
Texture2D MainTex : DIFFUSE_TEXTURE;

[vertex]
float2 uv;

[interpolators]
float2 uv;

[ps]
__hlsl__
void surface(INPUT input, inout LambertSurfaceOutput output)
{
	float4 c = tex2D(MainTex, input.uv) * Color;
	output.Diffuse = c.rgb;
	output.Alpha = c.a;
}

void main(INPUT input, inout OUTPUT output)
{
	// Import world normal - this will have either been exported by a simple pass-through
	// fragment which exported the normal coming from the vertex shader, or else it
	// might be a normal that was retrieved from a terrain normal map.
	float3 normal;
	import(_WorldNormal, normal = _WorldNormal);

	LambertSurfaceOutput s = (LambertSurfaceOutput) 0;
	surface(input, s);

	float4 ambient = float4(0.2, 0.2, 0.2, 1);
	float3 viewDirection = normalize(camera_position - input.world_position);

	// Import whatever lights have been exported by previous light fragments,
	// and process them one-by-one. Because light is additive, the final intensity of the light
	// reflected by a given surface is simply the sum of the ambient, diffuse and specular components.
	float4 final_color = ambient;
	import(light, final_color += LightingLambert(s, light, 1.0, viewDirection));

	export(float4, light_color, final_color);
}
__hlsl__